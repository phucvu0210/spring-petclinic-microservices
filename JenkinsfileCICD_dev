pipeline {
    agent any
    environment {
        DOCKERHUB_CREDENTIALS = credentials('dockerhub-credentials')
        K8S_NAMESPACE = 'dev'
    }

    stages {
        stage('Checkout Code') {
            steps {
                script {
                    def branchName = sh(script: 'git rev-parse --abbrev-ref HEAD', returnStdout: true).trim()
                    if (branchName == 'HEAD') {
                        branchName = sh(script: 'git branch --contains HEAD | grep -v detached | sed \'s/* //\' || echo HEAD', returnStdout: true).trim()
                    }
                    echo "Branch hi·ªán t·∫°i: ${branchName}"

                    // S·ª≠ d·ª•ng bi·∫øn c·ª•c b·ªô ƒë·ªÉ ki·ªÉm so√°t pipeline
                    def shouldRunPipeline = true
                    if (branchName != 'main') {
                        echo "Kh√¥ng ph·∫£i nh√°nh main. Pipeline s·∫Ω b·ªè qua c√°c b∆∞·ªõc ti·∫øp theo."
                        shouldRunPipeline = false
                    } else {
                        // Checkout nh√°nh main
                        checkout([$class: 'GitSCM', 
                                  branches: [[name: '*/main']], 
                                  userRemoteConfigs: [[url: 'https://github.com/phucvu0210/spring-petclinic-microservices.git']]])
                        sh 'git fetch --tags'

                        env.TAG_NAME = sh(script: 'git describe --tags --exact-match 2>/dev/null || true', returnStdout: true).trim()
                        if (env.TAG_NAME) {
                            echo "Commit hi·ªán t·∫°i c√≥ tag (${env.TAG_NAME}). Pipeline ch·ªâ ch·∫°y tr√™n commit ch∆∞a ƒë∆∞·ª£c g·∫Øn tag."
                            shouldRunPipeline = false
                        }
                    }

                    // G√°n gi√° tr·ªã v√†o bi·∫øn m√¥i tr∆∞·ªùng
                    env.SHOULD_RUN_PIPELINE = shouldRunPipeline.toString()

                    if (!shouldRunPipeline) {
                        return
                    }

                    env.COMMIT_ID = sh(script: 'git rev-parse --short HEAD', returnStdout: true).trim()
                    echo "‚úÖ ƒêang deploy commit: ${env.COMMIT_ID}"
                }
            }
        }

        stage('Build JAR') {
            when {
                expression { return env.SHOULD_RUN_PIPELINE == 'true' }
            }
            steps {
                script {
                    if (env.SHOULD_RUN_PIPELINE != 'true') {
                        echo "B·ªè qua stage Build JAR v√¨ nh√°nh kh√¥ng ph·∫£i main ho·∫∑c commit c√≥ tag."
                        return
                    }
                    sh './mvnw clean package -DskipTests'
                }
            }
        }

        stage('Build and Push Docker Images') {
            when {
                expression { return env.SHOULD_RUN_PIPELINE == 'true' }
            }
            steps {
                script {
                    if (env.SHOULD_RUN_PIPELINE != 'true') {
                        echo "B·ªè qua stage Build and Push Docker Images v√¨ nh√°nh kh√¥ng ph·∫£i main ho·∫∑c commit c√≥ tag."
                        return
                    }

                    def imageTag = env.COMMIT_ID
                    def serviceConfigs = [
                        [name: 'admin-server', dir: 'spring-petclinic-admin-server', port: 9090],
                        [name: 'api-gateway', dir: 'spring-petclinic-api-gateway', port: 8080],
                        [name: 'config-server', dir: 'spring-petclinic-config-server', port: 8888],
                        [name: 'customers-service', dir: 'spring-petclinic-customers-service', port: 8081],
                        [name: 'discovery-server', dir: 'spring-petclinic-discovery-server', port: 8761],
                        [name: 'genai-service', dir: 'spring-petclinic-genai-service', port: 8084],
                        [name: 'vets-service', dir: 'spring-petclinic-vets-service', port: 8083],
                        [name: 'visits-service', dir: 'spring-petclinic-visits-service', port: 8082]
                    ]

                    withCredentials([usernamePassword(credentialsId: 'dockerhub-credentials', usernameVariable: 'DOCKER_USERNAME', passwordVariable: 'DOCKER_PASSWORD')]) {
                        sh 'echo $DOCKER_PASSWORD | docker login -u $DOCKER_USERNAME --password-stdin'

                        for (def service in serviceConfigs) {
                            def serviceDir = service.dir
                            def serviceName = service.name
                            def exposedPort = service.port
                            def imageName = "${DOCKER_USERNAME}/spring-petclinic-${serviceName}:${imageTag}"
                            def jarFile = sh(script: "ls ${serviceDir}/target/*.jar | head -1", returnStdout: true).trim()

                            if (!jarFile) {
                                error "No JAR file found for ${serviceName} in ${serviceDir}/target/"
                            }

                            echo "Building Docker image for ${serviceName} with tag ${imageTag}..."
                            sh """
                                mkdir -p docker
                                cp ${jarFile} docker/${serviceName}.jar
                                cd docker
                                docker build --build-arg ARTIFACT_NAME=${serviceName} --build-arg EXPOSED_PORT=${exposedPort} -t ${imageName} .
                                docker tag ${imageName} ${DOCKER_USERNAME}/spring-petclinic-${serviceName}:latest
                                docker push ${imageName}
                                docker push ${DOCKER_USERNAME}/spring-petclinic-${serviceName}:latest
                                rm ${serviceName}.jar
                                cd ..
                            """
                        }
                    }
                }
            }
        }

        stage('Update Helm Values') {
            when {
                expression { return env.SHOULD_RUN_PIPELINE == 'true' }
            }
            steps {
                script {
                    if (env.SHOULD_RUN_PIPELINE != 'true') {
                        echo "B·ªè qua stage Update Helm Values v√¨ nh√°nh kh√¥ng ph·∫£i main ho·∫∑c commit c√≥ tag."
                        return
                    }

                    def values = readYaml file: 'helm/petclinic/values.yaml'
                    values.releaseTag = env.COMMIT_ID

                    def services = [
                        'adminServer',
                        'apiGateway',
                        'configServer',
                        'customersService',
                        'discoveryServer',
                        'genaiService',
                        'vetsService',
                        'visitsService'
                    ]

                    services.each { svc ->
                        values[svc].tag = env.COMMIT_ID
                        echo "Updated Docker image tag for ${svc} to ${env.COMMIT_ID}"
                    }

                    writeYaml file: 'helm/petclinic/values.yaml', data: values, overwrite: true
                }
            }
        }

        stage('Deploy to Kubernetes') {
            when {
                expression { return env.SHOULD_RUN_PIPELINE == 'true' }
            }
            steps {
                script {
                    if (env.SHOULD_RUN_PIPELINE != 'true') {
                        echo "B·ªè qua stage Deploy to Kubernetes v√¨ nh√°nh kh√¥ng ph·∫£i main ho·∫∑c commit c√≥ tag."
                        return
                    }

                    sh "helm upgrade --install petclinic helm/petclinic --namespace ${K8S_NAMESPACE} --create-namespace -f helm/petclinic/values-dev.yaml"
                }
            }
        }

        stage('Print Access Info') {
            when {
                expression { return env.SHOULD_RUN_PIPELINE == 'true' }
            }
            steps {
                script {
                    if (env.SHOULD_RUN_PIPELINE != 'true') {
                        echo "B·ªè qua stage Print Access Info v√¨ nh√°nh kh√¥ng ph·∫£i main ho·∫∑c commit c√≥ tag."
                        return
                    }

                    def nodeName = sh(script: "kubectl get nodes --no-headers | grep -v control-plane | awk '{print \$1}'", returnStdout: true).trim()
                    def nodeIp = sh(script: "kubectl get node ${nodeName} -o jsonpath='{.status.addresses[?(@.type==\"InternalIP\")].address}'", returnStdout: true).trim()
                    def servicePort = sh(script: "kubectl get svc api-gateway -n ${K8S_NAMESPACE} -o jsonpath='{.spec.ports[0].nodePort}'", returnStdout: true).trim()
                    echo "Access the application at: http://${nodeIp}:${servicePort}"
                    echo "Or use: http://petclinic.local:${servicePort} (after adding '${nodeIp} petclinic.local' to /etc/hosts)"
                }
            }
        }
    }

    post {
        always {
            echo "üßπ Cleaning up workspace..."
            cleanWs()
        }
        success {
            script {
                if (env.SHOULD_RUN_PIPELINE == 'false') {
                    echo "‚úÖ Pipeline skipped successfully (not main branch or tagged commit)."
                } else {
                    echo "‚úÖ Dev pipeline completed successfully."
                }
            }
        }
        failure {
            echo "‚ùå Dev pipeline failed. Check logs."
        }
    }
}